"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = linaria;

var _path = _interopRequireDefault(require("path"));

var _fs = _interopRequireDefault(require("fs"));

var _babelPreset = require("@linaria/babel-preset");

var _esbuild = require("esbuild");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * This file contains an esbuild loader for Linaria.
 * It uses the transform.ts function to generate class names from source code,
 * returns transformed code without template literals and attaches generated source maps
 */
const nodeModulesRegex = /^(?:.*[\\/])?node_modules(?:[\\/].*)?$/;

function linaria({
  sourceMap,
  preprocessor,
  esbuildOptions,
  ...rest
} = {}) {
  return {
    name: 'linaria',

    setup(build) {
      const cssLookup = new Map();
      build.onResolve({
        filter: /\.linaria\.css$/
      }, args => {
        return {
          namespace: 'linaria',
          path: args.path
        };
      });
      build.onLoad({
        filter: /.*/,
        namespace: 'linaria'
      }, args => {
        return {
          contents: cssLookup.get(args.path),
          loader: 'css',
          resolveDir: _path.default.basename(args.path)
        };
      });
      build.onLoad({
        filter: /\.(js|jsx|ts|tsx)$/
      }, args => {
        const rawCode = _fs.default.readFileSync(args.path, 'utf8');

        const {
          ext,
          name: filename
        } = _path.default.parse(args.path);

        const loader = ext.replace(/^\./, '');

        if (nodeModulesRegex.test(args.path)) {
          return {
            loader,
            contents: rawCode
          };
        }

        if (typeof esbuildOptions === 'undefined') {
          esbuildOptions = {};

          if ('jsxFactory' in build.initialOptions) {
            esbuildOptions.jsxFactory = build.initialOptions.jsxFactory;
          }

          if ('jsxFragment' in build.initialOptions) {
            esbuildOptions.jsxFragment = build.initialOptions.jsxFragment;
          }
        }

        const {
          code
        } = (0, _esbuild.transformSync)(rawCode, { ...esbuildOptions,
          loader
        });
        const result = (0, _babelPreset.transform)(code, {
          filename: args.path,
          preprocessor,
          pluginOptions: rest
        });

        if (!result.cssText) {
          return {
            contents: code
          };
        }

        let {
          cssText
        } = result;
        const slug = (0, _babelPreset.slugify)(cssText);
        const cssFilename = `${filename}_${slug}.linaria.css`;

        if (sourceMap && result.cssSourceMapText) {
          const map = Buffer.from(result.cssSourceMapText).toString('base64');
          cssText += `/*# sourceMappingURL=data:application/json;base64,${map}*/`;
        }

        cssLookup.set(cssFilename, cssText);
        return {
          contents: `
          import ${JSON.stringify(cssFilename)};
          ${result.code}
          `
        };
      });
    }

  };
}
//# sourceMappingURL=index.js.map