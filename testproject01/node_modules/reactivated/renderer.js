"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var _a, _b;
Object.defineProperty(exports, "__esModule", { value: true });
exports.server = exports.SOCKET_PATH = exports.serverRender = exports.simpleRender = exports.render = exports.renderPage = exports.BODY_SIZE_LIMIT = void 0;
var fs_1 = __importDefault(require("fs"));
var http_1 = __importDefault(require("http"));
var react_1 = __importDefault(require("react"));
var server_1 = __importDefault(require("react-dom/server"));
var react_helmet_async_1 = require("react-helmet-async");
// Useful when running e2e tests or the like, where the output is not
// co-located with the running process.
var REACTIVATED_CLIENT_ROOT = (_a = process.env.REACTIVATED_CLIENT_ROOT) !== null && _a !== void 0 ? _a : "../client";
// TODO: WHAT DOES THIS NEED TO BE? Even 100k was super fragile and a 10 choice field broke it.
exports.BODY_SIZE_LIMIT = "100000000k";
var renderPage = function (_a) {
    var html = _a.html, helmet = _a.helmet, context = _a.context, props = _a.props;
    return "\n<!DOCTYPE html>\n<html ".concat(helmet.htmlAttributes.toString(), ">\n    <head>\n        <script>\n            // These go first because scripts below need them.\n            // WARNING: See the following for security issues around embedding JSON in HTML:\n            // http://redux.js.org/recipes/ServerRendering.html#security-considerations\n            window.__PRELOADED_PROPS__ = ").concat(JSON.stringify(props).replace(/</g, "\\u003c"), "\n            window.__PRELOADED_CONTEXT__ = ").concat(JSON.stringify(context).replace(/</g, "\\u003c"), "\n        </script>\n\n        ").concat(helmet.base.toString(), "\n        ").concat(helmet.link.toString(), "\n        ").concat(helmet.meta.toString(), "\n        ").concat(helmet.noscript.toString(), "\n        ").concat(helmet.script.toString(), "\n        ").concat(helmet.style.toString(), "\n        ").concat(helmet.title.toString(), "\n    </head>\n    <body ").concat(helmet.bodyAttributes.toString(), ">\n        <div id=\"root\">").concat(html, "</div>\n    </body>\n</html>\n");
};
exports.renderPage = renderPage;
var PATHS = ["/", "/form/"];
var render = function (_a) {
    var context = _a.context, props = _a.props;
    var _b = require("../../node_modules/_reactivated"), Provider = _b.Provider, getTemplate = _b.getTemplate;
    try {
        var Template = getTemplate(context);
        var helmetContext = {};
        var rendered = server_1.default.renderToString(react_1.default.createElement(react_helmet_async_1.HelmetProvider, { context: helmetContext },
            react_1.default.createElement(Provider, { value: context },
                react_1.default.createElement(Template, __assign({}, props)))));
        var helmet = helmetContext.helmet;
        return {
            status: "success",
            rendered: (0, exports.renderPage)({
                html: rendered,
                helmet: helmet,
                props: props,
                context: context,
            }),
        };
    }
    catch (error) {
        return { status: "error", error: error };
    }
};
exports.render = render;
var simpleRender = function () {
    var input = fs_1.default.readFileSync(0);
    var _a = JSON.parse(input.toString("utf8")), context = _a.context, props = _a.props;
    process.stdout.write(JSON.stringify((0, exports.render)({ context: context, props: props })));
};
exports.simpleRender = simpleRender;
var serverRender = function (body) {
    var _a = JSON.parse(body.toString("utf8")), context = _a.context, props = _a.props;
    return (0, exports.render)({ context: context, props: props });
};
exports.serverRender = serverRender;
var OK_RESPONSE = 200;
var ERROR_REPONSE = 500;
// Relative path to keep it under 100 characters.
// See: https://unix.stackexchange.com/questions/367008/why-is-socket-path-length-limited-to-a-hundred-chars
exports.SOCKET_PATH = (_b = process.env.REACTIVATED_SOCKET) !== null && _b !== void 0 ? _b : "node_modules/_reactivated/reactivated.sock";
exports.server = http_1.default.createServer(function (req, res) {
    var body = Buffer.from("");
    req.on("data", function (chunk) {
        body = Buffer.concat([body, chunk]);
    });
    req.on("end", function () {
        var result = (0, exports.serverRender)(body);
        if (result.status === "success") {
            res.writeHead(OK_RESPONSE, { "Content-Type": "text/html; charset=utf-8" });
            res.end(result.rendered);
        }
        else {
            res.writeHead(ERROR_REPONSE, { "Content-Type": "application/json" });
            res.end(JSON.stringify(result.error, Object.getOwnPropertyNames(result.error)));
        }
    });
});
if (fs_1.default.existsSync(exports.SOCKET_PATH)) {
    fs_1.default.unlinkSync(exports.SOCKET_PATH);
}
exports.server.listen(exports.SOCKET_PATH, function () {
    var address = exports.server.address();
    if (address == null) {
        throw new Error();
    }
    else if (typeof address === "string") {
        process.stdout.write("RENDERER:".concat(address, ":LISTENING"));
    }
    else {
        process.stdout.write("RENDERER:".concat(address.port.toString(), ":LISTENING"));
    }
});
//# sourceMappingURL=renderer.js.map