"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var fs_1 = __importDefault(require("fs"));
// Must be above the compile import as get-stdin used by
// json-schema-to-typescript messes up the descriptor even if unused.
var stdinBuffer = fs_1.default.readFileSync(0);
var json_schema_to_typescript_1 = require("json-schema-to-typescript");
var ts_morph_1 = require("ts-morph");
var schema = JSON.parse(stdinBuffer.toString("utf8"));
var possibleEmptyUrls = schema.urls, templates = schema.templates, interfaces = schema.interfaces, types = schema.types, values = schema.values;
var urls = __assign(__assign({}, possibleEmptyUrls), { __reactivated_do_not_use: {
        route: "__reactivated_do_not_use",
        args: {},
    }, __reactivated_do_not_use_args: {
        route: "__reactivated_do_not_use_args",
        args: {
            _: "string",
        },
    } });
var project = new ts_morph_1.Project();
var sourceFile = project.createSourceFile("");
if (Object.keys(urls).length !== 0) {
    sourceFile.addVariableStatement({
        declarationKind: ts_morph_1.VariableDeclarationKind.Const,
        declarations: [
            {
                name: "urls",
                initializer: JSON.stringify(urls),
            },
        ],
    });
    var urlMap = sourceFile.addInterface({
        name: "URLMap",
    });
    urlMap.setIsExported(true);
    var withArguments = [""];
    var withoutArguments = [""];
    for (var _i = 0, _a = Object.keys(urls); _i < _a.length; _i++) {
        var name_1 = _a[_i];
        var properties = urls[name_1].args;
        var normalizedName = name_1.replace(/[^\w]/g, "_");
        var urlInterface = sourceFile.addInterface({
            name: normalizedName,
            properties: [{ name: "name", type: "'".concat(name_1, "'") }],
        });
        var argsInterface = sourceFile.addInterface({
            name: "".concat(normalizedName, "_args"),
        });
        for (var _b = 0, _c = Object.keys(properties); _b < _c.length; _b++) {
            var propertyName = _c[_b];
            argsInterface.addProperty({
                name: propertyName,
                type: properties[propertyName],
            });
        }
        urlInterface.addProperty({
            name: "args",
            type: "".concat(normalizedName, "_args"),
        });
        urlMap.addProperty({
            name: normalizedName,
            type: normalizedName,
        });
        if (Object.keys(properties).length === 0) {
            withoutArguments.push(normalizedName);
        }
        else {
            withArguments.push(normalizedName);
        }
    }
    sourceFile.addTypeAlias({ name: "WithArguments", type: withArguments.join("|") });
    sourceFile.addTypeAlias({
        name: "WithoutArguments",
        type: withoutArguments.join("|"),
    });
    sourceFile.addStatements("\n\n    type All = WithArguments|WithoutArguments;\n    export function reverse<T extends WithoutArguments['name']>(name: T): string;\n    export function reverse<T extends WithArguments['name']>(name: T, args: Extract<WithArguments, {name: T}>['args']): string;\n    export function reverse<T extends All['name']>(name: T, args?: Extract<WithArguments, {name: T}>['args']): string {\n        let route = urls[name].route;\n\n        if (args != null) {\n            for (const token of Object.keys(args)) {\n                route = route.replace(new RegExp('<(.+?:)' + token + '>'), (args as any)[token]);\n            }\n        }\n        return route;\n    }");
}
sourceFile.addStatements("\nimport React from \"react\"\nimport createContext from \"reactivated/context\";\nimport * as forms from \"reactivated/forms\";\nimport * as generated from \"reactivated/generated\";\n\n// Note: this needs strict function types to behave correctly with excess properties etc.\nexport type Checker<P, U extends (React.FunctionComponent<P> | React.ComponentClass<P>)> = {};\n\nexport const {Context, Provider, getServerData} = createContext<_Types[\"Context\"]>();\n\nexport const getTemplate = ({template_name}: {template_name: string}) => {\n    // This require needs to be *inside* the function to avoid circular dependencies with esbuild.\n    const { default: templates, filenames } = require('../../client/templates/**/*');\n    const templatePath = \"../../client/templates/\" + template_name + \".tsx\";\n    const possibleTemplate: {default: React.ComponentType<any>} | null = templates.find((t: any, index: number) => filenames[index] === templatePath);\n\n    if (possibleTemplate == null) {\n        throw new Error(\"Template \" + template_name + \".tsx not found\");\n    }\n    return possibleTemplate.default;\n}\n\nexport const CSRFToken = forms.createCSRFToken(Context);\n\nexport const {createRenderer, Iterator} = forms.bindWidgetType<_Types[\"globals\"][\"Widget\"]>();\nexport type FieldHandler = forms.FieldHandler<_Types[\"globals\"][\"Widget\"]>;\n\nexport const {Form, FormSet, Widget} = forms;\n");
// tslint:disable-next-line
(0, json_schema_to_typescript_1.compile)(types, "_Types").then(function (ts) {
    process.stdout.write("/* eslint-disable */\n");
    process.stdout.write(ts);
    for (var _i = 0, _a = Object.keys(templates); _i < _a.length; _i++) {
        var name_2 = _a[_i];
        var propsName = templates[name_2];
        sourceFile.addStatements("\n\nimport ".concat(name_2, "Implementation from \"@client/templates/").concat(name_2, "\"\nexport type ").concat(name_2, "Check = Checker<_Types[\"").concat(propsName, "\"], typeof ").concat(name_2, "Implementation>;\n\nexport namespace templates {\n    export type ").concat(name_2, " = _Types[\"").concat(propsName, "\"];\n}\n\n\n        "));
    }
    for (var _b = 0, _c = Object.keys(interfaces); _b < _c.length; _b++) {
        var name_3 = _c[_b];
        var propsName = interfaces[name_3];
        sourceFile.addStatements("\n\nexport namespace interfaces {\n    export type ".concat(name_3, " = _Types[\"").concat(propsName, "\"];\n}\n\n\n        "));
    }
    process.stdout.write(sourceFile.getText());
});
//# sourceMappingURL=generator.js.map